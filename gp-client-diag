#!/bin/bash
#
# 
#
# Local group policy diagnostic tool
#
# SPDX-License-Identifier: GPL-2.0-or-later
#

set -euo pipefail

. shell-getopt

PROG="${0##*/}"
PROG_VERSION='0.0.1'

cmd="run"
global_retval=0

declare -a MACHINE_SCRIPT			#Список имен загруженных скриптов для системы

print_version()
{
	cat <<EOF
$PROG version $PROG_VERSION

EOF
	exit
}

show_usage()
{
	cat <<EOF
$PROG - Local group polisy diagnostic tool.

Usage: $PROG [options] [<diagnostic-task>]

Options:
  -l, --list                list of diagnostic tasks;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.

Report bugs to https://bugzilla.altlinux.org/

EOF
	exit
}

TEMP=$(getopt -n "$PROG" -o "l,V,h" -l "list,version,help" -- "$@") || show_usage
eval set -- "$TEMP"

while :; do
	case "$1" in
		--) shift; break
			;;
		-l|--list) cmd="list";
			;;
		-V|--version) print_version
			;;
		-h|--help) show_usage
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

task_list="$*"

task_show()
{
	local func="$1"

	echo "$func"
}

task_run()
{
	local retval=126
	local func="$1"

	if test -n "$task_list"; then
		echo "$task_list" | tr ' ' '\n' | grep -q "^$func\$" ||
			return 0
	fi

	$func && retval=0 || retval="$?"
	test $retval = 0 || global_retval=1

	return $retval
}

task()
{
	local task="$1"

	case "$cmd" in
		list) task_show "$task"
			;;
#		run) task_run "$task" && echo "[DONE]: $task" || echo "[FAIL]: $task"
		run) task_run "$task"
			;;
		*) fatal "Unrecognized command: $cmd"
			;;
	esac
}

#Наличие установленного пакета gpupdate
rpm_status()
{
	rpm -qi gpupdate | grep "Version"
	echo "RPM :"
}

#Статус gpupdate-setup
gpupdate_setup_status()
{
	gpupdate-setup status | grep "enabled" && return 0 || return 1
}

#Состояние системного процесса gpupdate.timer
gpupdate_system_timer_status()
{
	systemctl status gpupdate.timer | grep "Active: active" && return 0 || return 1
}

#Состояние пользовательского процесса gpupdate.timer
#gpupdate_user_timer_status()
#{
#	Нужно сделать
#}

#Состояние системного процесса обработки скриптов
gpupdate_system_scripts_status()
{
	systemctl status gpupdate-scripts-run.service | grep "Active: active" && return 0 || return 1
}

#Наличие файлов в каталоге со скриптами для системы
gpupdate_system_scripts_cache()
{
	local xreturn=1
	local ssc=
	local per=
	local per2=
	local dir_sc="/var/cache/gpupdate_scripts_cache/machine/"
	[[ -d "$dir_sc" ]] && ssc=$(find $dir_sc -type f | wc -l) || echo "Каталог пустой"
	[[ $ssc -ne 0 ]] && echo "В каталоге $dir_sc файлов: $ssc"
	if [[ $ssc -ne 0 ]]
	then
		per=$(find $dir_sc -type f)
		for i in $per; do
			per2=$(file -i $i)
			echo ${per2#*machine}
		done
	    xreturn=0
	fi
	[ $xreturn -ne 0 ] && return 1 || return 0
}

#Наличие файлов в каталоге со скриптами для пользователей
gpupdate_users_scripts_cache()
{
	local xreturn=1
	local usc=
	local per=
	local per2=
	local dir_uc="/var/cache/gpupdate_scripts_cache/users/"
	[[ -d "$dir_uc" ]] && usc=$(find $dir_uc -type f | wc -l) || echo "Каталог пустой"
	[[ $usc -ne 0 ]] && echo "В каталоге $dir_uc файлов: $usc"
	if [[ $usc -ne 0 ]]
	then
		per=$(find $dir_uc -type f)
		for i in $per; do
			per2=$(file -i $i)
			echo ${per2#*users}
		done
	    xreturn=0
	fi
	[ $xreturn -ne 0 ] && return 1 || return 0
}

#Проверка кодировки файлов со скриптами для системы
#gpupdate_system_scripts_status()
#{

#}

task rpm_status
task gpupdate_setup_status
task gpupdate_system_timer_status
#task gpupdate_user_timer_status
task gpupdate_system_scripts_status
task gpupdate_system_scripts_cache
task gpupdate_users_scripts_cache

exit "$global_retval"
